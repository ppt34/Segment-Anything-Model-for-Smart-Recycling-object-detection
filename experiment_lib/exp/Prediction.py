
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: dev_nb/07_Prediction.ipynb

import torch

def get_pred_class_function(god):
    pred_func_config = god.config['model']['predict_class_function']

    if pred_func_config['name'] == 'argmax':
        return lambda pred: pred.argmax(dim=pred_func_config['dim'])

    elif pred_func_config['name'] == 'binary_threshold':
        return lambda pred: (pred.squeeze(-1) > pred_func_config['pred_1_threshold']).int()

    elif pred_func_config['name'] == 'fish_hierarchical_preds':
        return lambda pred: torch.max(pred[0], dim=1)[1] * (torch.max(pred[1], dim=1)[1] + 1)

    elif pred_func_config['name'] == 'argmax_threshold':
        return lambda pred: (pred.argmax(dim=1) + 1) * ((pred >= pred_func_config['threshold']).any(dim=1).long())

    raise Exception(f"predict_class_function with name '{pred_func_config['name']}' not supported.")

def get_pred_dict(god, model, dl, include_x=False, pred_class_function=None, device='cuda'):
    if not pred_class_function: pred_class_function = god.pred_class_function
    model = model.to(device)
    model.eval()
    pred_dict = {}
    n = 0
    all_xb, all_yb, all_pred, all_pred_class, all_loss = [], [], [], [], []
    with torch.no_grad():
        for xb, yb in dl:
            xb, yb = xb.to(device), yb.to(device)

            n += yb.size(0)
            pred = model(xb)
            pred_class = pred_class_function(pred)
            loss = torch.tensor([god.criterion(p.unsqueeze(0), y.unsqueeze(0)) for p,y in zip(pred, yb)])

            if include_x: all_xb.append(xb.cpu())
            all_yb.append(yb.cpu())
            all_pred.append(pred.cpu())
            all_pred_class.append(pred_class.cpu())
            all_loss.append(loss.cpu())

    model = model.to('cpu')
    return {
        'idx': torch.arange(n).tolist(),
        'x': torch.cat(all_xb).tolist() if all_xb else None,
        'y': torch.cat(all_yb).tolist(),
        'pred': torch.cat(all_pred).tolist(),
        'pred_class': torch.cat(all_pred_class).tolist(),
        'loss': torch.cat(all_loss).tolist()
    }